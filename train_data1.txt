both a renderscript and opengl are used for getting high performance graphics and animation s.but still opengl is the best option to get high performance graphics because it is well documented and you will have more control over the glsurfaceview .but in renderscript some of the classes are depreciated in the current versions .its almost not possible to make a rssurfaceview to transparent  __label__documented
it s not too hard for the fat filesystems as it s quite simple and well documented but it s more difficult for ntfs as the filesystems is much more complicated and not-so-well documented  __label__documented
i would recommend using theano binary lstm link or keras tutorial for this because they are fairly simple to understand and are well documented  __label__documented
given the simplicity of what you ve described as i understand it i would recommend using robobrowser as it relies on well-documented and supported python libraries requests and beautifulsoup and thus is usually easier for beginners like me and you  __label__documented
either way i intend to use smarty partly because i have lots of experience with it and partly because its much more well documented and has much more functionality than blade and to me the syntax is slightly cleaner than twig although the template engine is not the point of this question really  __label__documented
this implies that at the least the type signature of this function in the documentation is wrong as it accepts more than just double and int  __label__documented
if you are new to linux i would recommend ubuntu as that is a popular linux distro and is well documented and has a super active community that can help you out if when you get stuck  __label__documented
i m only interested in a small subset of properties of the json so gson was nice because of its very concise syntax but i m losing an internal battle to continue to use gson as jackson is already used elsewhere in our application and it has documented better performance which i concede are both good reasons to lose gson  __label__documented
finally if soappy just isn t working for you try suds it s better documented than soappy  __label__documented
xcb is simpler to use has a better response to a multithread environment but lacks documentation while xlib is a more dated complex tool better documented and fully implemented  __label__documented
i managed to write increment and decrement functions but the addition and subtraction seem even less documented and harder to write  __label__documented
i also find ant with ivy to be better documented than maven although that s not too difficult  __label__documented
it seems a little bit more straight forward than kerberos but provides good ntlm sso capabilities  __label__function
fragment primary support more dynamic large ui screens like tablet.because tablet screens is much larger than normal handset  __label__function
you need to use tolist to convert it from ienumerable because the ilist interface supports more functionality than the ienumerable interface  __label__function
from my experience of both i would suggest that velocity is a little bit simpler but freemarker is more powerful  __label__function
powermockito is an extension of other mocking frameworks like mockito or easymock that comes with more powerful capabilities  __label__function
the other way round returning a subclassing that is a more specific class does not break the contract because the subclassing has at least the same functionality as the superclass  __label__function
the reason that you would choose adfs over iwa is that both authenticate against ad but only adfs adds sso and federation functionality  __label__function
i would like to use mongo js and mongoose in the same app.i require mongo js as i don t want write schema for a specific functionality of the app as it includes nested and complex data.i tried mongoose but that just makes it more difficult.with mongojs i could directly write mongodb queries and execute.whereas for other functionalities like validation and simple schema mongoose would be better so can i use both  __label__function
myisam is slightly faster than innodb and implements the fulltext index which is quite useful for integrating search capabilities  __label__function
however i do not know if webstorm has a comparable option like that as it has less functionality than phpstorm or even intellij  __label__function
if you have access to memcached or apc on your webhost some shared plans disable this functionality look them up as they are considered fairly high-performance forms of caching as it utilizes the system memory directly memcached is more suited for distributed systems  __label__function
if you have a mac i would recommend aquamacs which is a beginner-friendly version of gnu-emacs and therefore has all the power of emacs while still offering standard copy-paste save and other features including normal file dialogs and windows  __label__function
in my opinion this is a more elegant solution than jsf and i think tapestry s ioc container makes it more powerful than wicket  __label__function
the restful services are rather thin and completely stateless whereas the admin console is stateful and has more interactive functionality and therefore more memory and processing required  __label__function
swing is relatively similar to awt apart from the fact that swing has more capabilities awt is probably the simplest form to start out with and has most if not all of the tools to complete your project hope this helps  __label__function
note that it currently does not support true parallelism you won t have two threads running ocaml code in parallel but it doesn t matter as ocaml is much faster than many other languages for example on a quadcore the language shootout shows that ocaml outperforms even haskell with multicore capabilities  __label__function
my guess is that server-side implementation may turn out to be more flexible and more powerful than client-side as i can add functionality to the server easily as long as the client understands it  __label__function
among other things the apple template code will include creation of a glkbaseeffect which provides some shader functionality that seems to be required in order to be able to draw with opengl-es 2.0  __label__function
hash is newer and seems to support more hashing alogrithms than crypt  __label__function
for similar functionality that speaks pandas but has more flexible features you could use the facetgrid object from seaborn  __label__function
i have used virtual mode and works fine but i will lose filtering sorting grouping functionality which i need them somehow  __label__function
lxml is faster than beautifulsoup i think and has much better functionality while remaining relatively easy to use  __label__function
i personally would just skip using awt and move to swing which provides better built in functionality for this type of thing  __label__function
wicket s goal is to support static typing to the fullest extent whereas tapestry is more about saving lines of code  __label__function
however i find postgresql to support more sql features than mysql and be more efficient when handling more data  __label__function
sendmessage type functions will be slightly slower since they have more coding inside them allowing them to work with more than just mouse and keyboard functionality  __label__function
i just upgrade the driver the old versioning was even worse now i have some functionality at least it was from like 2005 the new one also performs much better i have also made this library in c# and am using .net 4  __label__function
this paper goes into this in depth but if you use a standard lda package i d recommend mallet they should have this functionality already  __label__function
the demonstration of tcpdf i saw at the following presentation showed that tcpdf may have more in-built capabilities the fpdf  __label__function
jpgraph has far more capabilities than phpgraphlib  __label__function
this is the first time i was working with obout controls.previously i was working with telerik controls and so i had a good chance of comparing these two set of controls.i would prefer obout for its light weight and functionality  __label__function
instead you can support more than the jks and try the default keystore type and if it fails try the #pkcs12  __label__function
testng has more capabilities and can be helpful with integration tests junit is more focused on unit tests  __label__function
in my reading it seemed iqueryable had more functionality for linq to sql but since i am returning a simple two column list then i only need to return an ienumerable or list  __label__function
many of the libgdx and android classes are designed this way they implement a bit of functionality but expect subclassing to implement more and the subclassing is expected to invoke the superclass method  __label__function
sometimes your mxml does not get you the itch of what you are looking and actionscript gives you more power  __label__function
we prefer composition over inherited because when we add particularly or change functionality by subclassing we couple that new functionality to the class - so anywhere we need the new functionality we need that class  __label__function
apc gives you some more functionality than memcached  __label__function
however i find postgresql to support more sql features than mysql and be more efficient when handling more data  __label__function
powermockito is an extension of other mocking frameworks like mockito or easymock that comes with more powerful capabilities  __label__function
i can see the usage of watin and watij reducing as more developers move to selenium 2.0 webdriver which will offer the same functionality as watir using a different api and multiple programming languages  __label__function
please keep in mind that qmake and qbs are two very different build systems with fundamentally different designs and capabilities and qbs verbosity is in part due to its fundamental architectural differences which make it far more powerful than qmake will ever be capable of  __label__function
the qtablewidget is slightly easier to implement than the qtableview which also needs a qtablemodel as backend but it has less capabilities  __label__function
vb.net is a better language than vb6 use its com capabilities to save you from writing endless sketchy vb6 code  __label__function
one could argue that a lighter framework such as sinatra if you re going to use ruby or something like bottle python or the javascript stack of node.js + express would be a better fit if you truly are just going to create a restful api + some landing pages but rails does this perfectly fine as well and has a lot of other functionality that will be available for you to grow into if the time ever comes  __label__function
i ve been modeling different possibilities of obtaining a decision in form of an enum to compare them expecting library functions of simulink performing better than implementing the same functionality calling matlab functions  __label__function
wpf .net represents more functionality than straight swing or swt but the eclipse netbeans spring rcp projects provide a much more comprehensive foundation for complex and modular gui applications  __label__function
cakephp is newer more feature rich and heavier than codeigniter codeigniter is designed to have a much smaller footprint so you will most likely find yourself creating functionality in codeigniter to match cake s  __label__function
although this problem sort of yells delegate it s much easier with subclassing since you intend to inherited almost all the same functionality  __label__function
i ended up defining an static string in each subclass holding the tag of the element so i decided to turn the interface into an abstract-class and give it more functionality  __label__function
at the same time the compilation phase for a dfa is typically more complex than for an nfa and dfas don t have all the capabilities of nfas  __label__function
depending on what you want to do inside loops and the capabilities of your compiler range-based for-loop might be a better solution  __label__function
even though aurora has better capabilities i prefer marathon due to auroras complexity overhead and lack of ui for control api  __label__function
perforce offers more advanced branching and merging capabilities than svn  __label__function
you can override a method in a subclassing to add more functionality to what the superclass has  __label__function
obviously for something like show hide functionality a checkbox makes more sense than a button  __label__function
in general lxml offers better capabilities than elementtree and there s no need to mix them  __label__function
qa verifies functionality and approves or disapproves it then i m verifying code and if it is ok i merge his work into master by fast-forward or rebasing for better commits history  __label__function
from the mozilla perspective the purpose of these changes except for adding more capabilities for use by web developers is to lead up to javascript 2.0 that is being developed as the next revision of ecma 262 revision 4 tc39 workgroup  __label__function
for list explicitly yes it should be private depending on what the functionality you re exposing is supposed to do interfaces such as ienuemerable icollection or ilist would be a better choice or if you re exposing a collection see slaks reply  __label__function
this is kind-of the functionality you for instance see but you instantly already see that there it s called at an instance and the fact it requires to extends rather then implements pdostatement has more to do with the c-level implementation functionality of that class  __label__function
icollection adds counting and ilist then gives richer functionality including find add and remove elements by index or via lambda expressions  __label__function
my personal experience with both richfaces mixed better with other jsf libs icefaces has more advanced ajax capabilities like server sided push kinda like comet the basic ajax functionality is easier to set up and use but plays difficult sometimes when you mix it with other jsf libs  __label__function
you can hide show the status bar on android 4.1 api level 16 and higher by using hide show functionality  __label__function
i have found that jedit has better plugins for providing some of the more ide-oriented capabilities but like boltclock said notepad++ is really just a powerful text editor and does not try to be a one-stop-shop ide  __label__function
if you need spatial data capabilities postgis with postgresql is better than mysql  __label__function
further to this i m still opting for scoreloop and i can confirm this behaves the same regarding one score per user but it offers a lot more functionality and does seem to respond much quicker than openfeint did for me  __label__function
i would actually recommend ember.js or angular or backbone.js as they provide the exact functionality you re looking for  __label__function
some wrappers like tbb and ppl offer far more functionality than the standard libraries  __label__function
in studio 3 much of this sort of functionality is still coming as aptana is going more of a textmate bundle route for a great deal of their features which i think is really cool  __label__function
mysql is more widely supported and a little easier to use but postgresql has some very cool features and functionality that s worth taking a gander at  __label__function
they are functionally identical however it can be argued that the for-loop is less error prone because all of loops functionality is right there together  __label__function
cfstring has some slightly better functionality than nsstring but is a bit harder to use  __label__function
memcached has more functionality but is intended for distributed environments while apc works on single servers only  __label__function
if you would like a unified front-end for elasticsearch and opentsdb you could consider grafana which has support for both elasticsearch and opentsdb but less functionality than kibana in regard to elasticsearch  __label__function
obviously this may cause problems such as missing functionality that was released in later versioning of devtools but if you can t upgrade it s better than not having it  __label__function
i would recommend iirf ionic s isapi rewrite filter which is a rewriter for iis that unlike isapi_rewrite is completely free for the full functionality  __label__function
i am pretty sure mysql have similar capabilities of importing csv i just generally prefer postgresql  __label__function
same functionality different machine code output bit shifting operations are almost always faster than multiplication division on most architectures  __label__function
since most of the functionality of highcharts is found in highstock you re probably better off to just use highstock for whatever application needs the range selector  __label__function
the benefit of both apache is more powerful and extensible useless if you don t need that power but anyway... and lighttpd is faster at static content  __label__function
it only adds some more java ee capabilities ejb and so on and of course the ibm sausage over it so i wouldn t expect websphere to be much faster than tomcat  __label__function
testng has more capabilities and can be helpful with integration tests junit is more focused on unit tests  __label__function
my personal experience with both richfaces mixed better with other jsf libs icefaces has more advanced ajax capabilities like server sided push kinda like comet the basic ajax functionality is easier to set up and use but plays difficult sometimes when you mix it with other jsf libs  __label__function
i d recommend bundler for versioning gems although both rvm and rbenv also have this functionality  __label__function
instead of using the endian conversion functions you could use the qdatastream functionality with any qiodevice which is much easier and more intuitive in my opinion  __label__function
crypto++ and openssl both implement needed functionality but i think crypto++ will be easier to use since it has less code  __label__function
flask is more focused on simplicity instead of functionality while django has more functionality  __label__function
jogl is more java-like whereas lwjgl provides more gaming functionality on top of opengl access  __label__function
jvm hosted languages are generally going to be faster than traditional mri ruby and both java and scala are generally faster than jruby when it comes to raw cpu capabilities  __label__function
maven 2 has a steeper learning curve but provides a much richer set of functionality for building your projects and eclipse integration through m2e or iam  __label__function
rickshaw is a graph library focused on time series whereas d3.js is more of a framework so it gives you much more functionality  __label__function
frameworks like firebase angular-fire lib have handy built in auto-sync functionality alternatively the rest post put request is a more traditional design pattern  __label__function
on one hand slick2d is fast and simple but it seems lwjgl is more adaptable in the sense that it has both 2d and 3d capabilities  __label__function
you can use other framework like elasticsearch and kibana to have more functionality available for the logs  __label__function
google-chrome extensions are much easier to learn and create than firefox  __label__learn
codeigniter has the lower learning curve overall so i would recommend it over cakephp  __label__learn
d3.js has a steeper learning curve than chart.js but once you get the hang of it you can do pretty much anything graph related with it.official site is here  __label__learn
for students in computer science major learning programming on linux freebsd is much better than doing these on windows  __label__learn
if you wanted to go the php route use something like cakephp everyone will say laravel but the learning curve for laravel is much steeper than it is for other less flexible but more compact frameworks  __label__learn
i think you ll find that web2py is even easier to learn and use than rails and django  __label__learn
yii has a higher learning curve than say codeigniter and cakephp  __label__learn
on the other hand swift is easier to learn especially if you have objective-c background so it can be adopted during the time slowly and paralelly with using objective-c  __label__learn
it is written in tcl which is a language somewhat simpler than perl but broadly in the same family and not difficult to learn  __label__learn
they are sufficiently similar that i d recommend starting with mysql but learning postgresql as well  __label__learn
erlang has a steeper learning curve compared to elixir  __label__learn
scheme is intentionally more compact than common lisp and you ll find that you can learn the language very quickly  __label__learn
i d recommend vim if you are going to learn one or the other but i know emacs users will strongly disagree  __label__learn
you can build apps a lot quicker with yii due to the code-gen and active record but it will be a bit harder to learn than codeigniter  __label__learn
as others have pointed out ocaml s learning curve will be lower than haskell s  __label__learn
i don t know about emacs but i would recommend learning vim for a beginner in a heartbeat  __label__learn
i have found highcharts to have a steeper learning curve than flot or rgraph imho  __label__learn
another reason is that mergesort needs more memory because it s hard to implement it as an in-place sort  __label__memory
try vtd-xml it is much faster than jdom upto 10x and dom4j or dom and also memory efficient  __label__memory
if int is 4 bytes and represents 2 bytes the int consumes more memory than the chars -array so you are not initialising the full int -memory to 0 by setting all chars -variables  __label__memory
int storage may require less memory than double on some systems  __label__memory
int needs less memory comparing to double numbers  __label__memory
nginx uses an event based non blocking single thread and the memory usage is relatively much lower than apache  __label__memory
i know that sqlite in tests should be fast because it is run in-memory and all that stuff but it is just still much slower than normal postgresql mysql database  __label__memory
as for variables each variable is a reference and will take up 8 bytes of memory even if it stores nothing int will generally only take up 4 bytes and boolean are even more optimized but these are special cases  __label__memory
but sometimes memcpy performs faster than strcpy because it moves blocks of memory at a time which allows it to perform some optimization i will not go into details here  __label__memory
prefer using malloc or calloc for larger chunks of memory  __label__memory
i remember somewhere i have read that calloc is slower than malloc because calloc performs initialization to zero after performing memory allocation  __label__memory
i m writing a program for a class where the basic problem is using a vector of unsigned int and bitwise operation to imitate a vector of boolean but use much less memory  __label__memory
allocating more memory with malloc does not prevent the memory error if the free call inside the dosomething method is incommented  __label__memory
on top of that the memory allocated with malloc will take up more space than the actual string both because the malloc and free functions need a bit of information next to the memory block to be able to do their job and because typically the size is rounded up to some good size 8 16 or 32 bytes  __label__memory
but do keep in mind you re optimizing for a particular js engine when you re doing that v8-optimized code might generate cleaner memory in google-chrome and safari but for all you know ie might make a complete hash of things or some of the tricks you ve used cause firefox to slow down more than a fairly large array would have done in the first place  __label__memory
ironically enough its object model show more details than it hide - good for learning but bad for abstraction  __label__learn
emacs and vim have a bigger learning curve but they re also very powerful especially if you re already using them for something else  __label__learn
i would advise you to try wicket it is very easy to learn much easier than jsf and it let s you re-use many existing components as well  __label__learn
it sounds from this that it would be much easier to use declarative styles all the time but there s usually a steep learning curve for declarative languages and most people prefer imperative  __label__learn
download xcode free and learn objective-c or swift swift is easier to learn than objective-c  __label__learn
an alternative to using your own mock class they start to build after a while would be to use a mocking framework such as nsubstitute or moq it s more of a learning curve but quicker in the long run  __label__learn
personally i would recommend testng although if you re just starting junit is slightly less of a learning curve  __label__learn
for the record jmock as of today supports more complex scenarios than mockito that s why the initial learning curve is steeper  __label__learn
bazaar is imho easier to learn than git  __label__learn
if you want to learn functional programming on its own terms languages like haskell and scheme may be better choices  __label__learn
ocaml will be easier to learn if you coming from almost any other language this is because haskell is as function as functional languages get and working with mutable random access structures can be a little clunky in haskell  __label__learn
although vhdl and verilog are much harder to learn i suggest you start right away  __label__learn
postgresql is worth learning and much more advanced than mysql  __label__learn
having said that web2py has a lower initial learning curve than django as it was specifically designed as a learning tool  __label__learn
once you re past the basics with c++ learning how to use parts of stl and then how it works will be better than tackling boost  __label__learn
keras is a higher level library that is much easier to learn than tensorflow and you have more sample code online  __label__learn
i would recommend using beautifulsoup or lxml it s worth the learning curve  __label__learn
once you re ready to choose an hdl i heartily recommend verilog having learned vhdl first  __label__learn
sure there is a learning curve with maven but reading a pom.xml is far easier than reading a build.xml  __label__learn
a better bet might be to install spim and to learn mips assembly which is more straightforward than x86 anyways  __label__learn
i think that functional declarative programming haskell scheme lisp etc is more powerful and more abstract than imperative programming and therefore is intrinsically harder to learn  __label__learn
i agree with previous answers but i would also recommend to use proper java build tool - like ant perceived easier to use but not necessary or maven perceived more difficult to use but really worth learning  __label__learn
junit is more direct and simpel to use if you start to learn java testng has more features but maybe is more complex  __label__learn
entity-relationship diagram may be easier for you to learn  __label__learn
for instance zeromq can leverage udp multicast to run faster than any tcp protocol but the application programmer doesn t need to learn a new api  __label__learn
i m significantly more comfortable with apache but learning to use nginx has been pretty exciting or as exciting as learning to configure a new webserver can be  __label__learn
but be prepared that learning curve for robotlegs and parsley could be steeper for some  __label__learn
while you could use -cp to javac to add the required dependencies to this compilation you d be far better served by learning ant or maven  __label__learn
i m worried that this will effectively upgrade my existing 1.6 to 1.7 the newer gives me lots of memory issues in my apps - yeah that s as backwards as it sounds the newer versioning being worse at memory management - probably due to how our apps are built  __label__memory
if new member fields are declared in the subclassing then yes a subclassing presumably uses more memory since it has all the fields declared in the superclass plus all the fields declared in the subclassing  __label__memory
most likely double is bigger than int and it overruns the memory for  int needs less memory comparing to double numbers  __label__memory
final result will be of type ienumerable and in terms of performance this would be better than iqueryable since here join is taking place between in memory collections  __label__memory
xrange will give you an iterable object that won t use memory as you iterate a for-loop is cleaner than a while loops + counter if you ask me  __label__memory
memory allocation in java is 5x to 10x faster than malloc calloc etc  __label__memory
also have a look at nginx for example it is fast and uses less memory than apache to handle client connections  __label__memory
one option is to use visualvm however a commercial profiler like yourkit may handle larger memory sizes better  __label__memory
when you want to allocate memory via functions as malloc and calloc it is better that you use a variable for the size of memory to be allocated  __label__memory
the os heap uses the cpu s virtual memory hardware and is free from fragmentation issues and can even effectively use the disk s swap space allowing you to allocate more memory than available ram  __label__memory
my experience is that you should prefer vmware but that s only because i had some crashes and memory loss with virtualbox  __label__memory
another reason is that mergesort needs more memory because it s hard to implement it as an in-place sort  __label__memory
for if your solving algorithm size is greater than the processors cache size the cpu must retrieve pieces of code from main memory or l2 cache which is a slower operation  __label__memory
now assuming that your inner loops is more complex and the simple for-loop is slower let s look at how much memory we save by avoiding broadcasted data in a parfor with 4 workers and a dataset with 50 million rows for about 760 mb in ram  __label__memory
to explain why a for-loop is faster than a for in loops is basically understand the underlying data structures used to store the data in memory  __label__memory
you re getting the outofmemory because if you declare int 1000 the memory is allocated immediately additionally double take up more space than ints-an int representation will also save you space  __label__memory
myisam uses less memory than innodb and the actual data files are often quite a bit larger for innodb  __label__memory
first don t use wav as it takes up too much memory mp3 is better  __label__memory
if an ivar is going to be changed frequently declaring a properties and always using the accessor will make it easier to avoid memory management errors  __label__memory
you will need about six times less disk space to store and memory to process your dataset compared to innodb or about 2-3 times less than archived myisam  __label__memory
dr printf uses the stack overwriting some of the space pointed by str but since the int array is bigger in memory than the chars array it is far ahead in the stack and doesn t get overwritten  __label__memory
we started off using objects int double and had less than desirable performance both in terms of memory and speed  __label__memory
int needs more memory than what chars occupies and the conversion cannot be done in a safe manner  __label__memory
very fast static assets nginx is faster than apache at serving static assets css js images ... and uses very little memory to do so  __label__memory
the restful services are rather thin and completely stateless whereas the admin console is stateful and has more interactive functionality and therefore more memory and processing required  __label__memory
i ve heard that rar decompression requires much more memory than zip decompression  __label__memory
suppose char p malloc n assigns more than n say n bytes of memory are allocated and free p is used to free the memory allocated to p  __label__memory
if you use shellsort no extra memory is needed at all though shellsort will be much slower than quicksort  __label__memory
according to these benchmarks it also uses less memory and cpu resources than nginx or lighttpd while running faster  __label__memory
with the cast that bad stuff is undefined behavior most likely double is bigger than int and it overruns the memory for i  __label__memory
everyone know int needs aroud 4 times more memory than chars  __label__memory
int occupy more memory than boolean so the heap got corrupted  __label__memory
or would it be good practice to use an unsigned chars in this case since it allocates less memory than a short int  __label__memory
use a radix tree wiki or trie wiki if you are concerned about performance.the radix tree is more memory efficient compared to a trie  __label__memory
if you re interested there is another data structure called a dawg directed acyclic word graph that is similar to the trie but uses substantially less memory  __label__memory
i mean by light weight i thought maybe the swing components occupy less memory than the awt components  __label__memory
if you re interested there is another data structure called a dawg directed acyclic word graph that is similar to the trie but uses substantially less memory  __label__memory
int storage may require less memory than double on some systems  __label__memory
but after one hour i see that firefox and google-chrome got more that 1 gb of memory and sometimes even firefox crashes  __label__memory
upgrade solr to a newer versioning seems have sort this problem likely newer versioning has a better heap memory management  __label__memory
if you care about memory a std ostringstream can be more useful that the + operator  __label__memory
sortedlist appears to use less memory and is technically a binary tree where sorteddictionary is faster with unsorted data  __label__memory
if you know in advance the number of elements and don t need flexibility an array of millions of int or double will be more efficient in memory and marginally in speed than a list because indeed they will be stored contiguously and accessed instantly  __label__memory
firefox allocates lots of memory during that preloading up to 20-30 times more than google-chrome or safari do and even twice as much as ie  __label__memory
gecko is often considered to consume less memory than webkit but this depends a lot on how the browser is implemented  __label__memory
gecko is often considered to consume less memory than webkit but this depends a lot on how the browser is implemented  __label__memory
the problem is that memcpy is only slighly slower than memset when i expect it to be about two times slower since it operations on twice the memory  __label__memory
nginx uses less memory than apache given the size of your setup i would definitely recommend that  __label__memory
i ve heard that rar decompression requires much more memory than zip decompression  __label__memory
one interesting experiment you can try is to try and malloc more memory after you free d that pointer  __label__memory
according the books the variations of type integer occupy more or less bytes of memory depending on the architecture however the type unsigned short values can get up to 65 535 since the type unsigned long 4 294 967 295  __label__memory
a virtual memory is a concept to work for files bigger than ram by using the pages and swapping with disk and ram  __label__memory
just wanted to weigh in my two cents what serialworm and thephpdeveloper said share the fact that memory ram is much faster than any disk io bound operation you come up with  __label__memory
i switched from apache to nginx to save memory especially to serve static file i seem to be using about 75 less memory with nginx  __label__memory
when people talk about pypy using less memory than cpython this is a major part of what they re talking about  __label__memory
assuming the total amount of memory being initialized in your two examples is the same allocating the memory with calloc might be faster than allocating the memory with malloc and then zeroing them out in a separate step especially if in the malloc case you zero the elements individually by iterating over them in a loop  __label__memory
i know nginx has lower memory footprint and little faster than apache in serving static files  __label__memory
in case of primitives memory comes into play.if you are going to store double into int as in your example double takes more memory as compare to integer.so there is chance of data lose.so compiler throw error.if you cast yourself then you know what you are doing so compiler let that do  __label__memory
memory allocation in java is 5x to 10x faster than malloc calloc etc  __label__memory
you made the right choice using setinterval instead of settimeout here as in this case settimeout would have been less efficient with memory resources  __label__memory
i read that settimeout is less cpu resources intensive than setinterval  __label__memory
servers like lighthttp and nginx can handle large amounts of traffic in much less memory than apache if you can sacrifice apache s power and flexibility or if you just don t need those things which often you don t  __label__memory
accessing the main memory ram is much faster than reading values from the hard disk  __label__memory
the problem is that memcpy is only slighly slower than memset when i expect it to be about two times slower since it operations on twice the memory  __label__memory
another reason is that mergesort needs more memory because it s hard to implement it as an in-place sort  __label__memory
sortedlist appears to use less memory and is technically a binary tree where sorteddictionary is faster with unsorted data  __label__memory
the amount of memory reserved depends on the data type a chars will take up more memory than an int  __label__memory
writing a fast memory allocator that consistently outperforms malloc free is non-trivial work however and there are issues to consider like memory alignment  __label__memory
the most urgent one that comes to mind is that a double is wider than an int on your platform and garbage memory is read  __label__memory
since superclass is smaller than subclassing one should use memory object carefully  __label__memory
calloc itself is slower than malloc because you have to spend some time to clear the contents of allocated memory  __label__memory
a dawg has better memory performance if the strings have many common suffixes but they are more expensive and difficult to build and update so start with a trie  __label__memory
and now i have learned that innodb uses more memory at-least while reading than myisam engine so i am trying to change the default engine of mysql to use myisam  __label__memory
i put my pictures in the drawable folder which on a xhdpi screens like mine will cause android to upsample everything twice to match xhdpi against mdpi and will result in a 400 memory usage twice the width and twice the height so 4 times as many pixels  __label__memory
also calloc is slower than malloc from operating system memory allocation perspective  __label__memory
cmd processors consumes more than 60 of cpu and memory and runs for a while  __label__memory
fiddly stuff and this is one case where i d recommend using malloc free realloc rather than c++ memory management  __label__memory
for a counterexample i think scheme programs ran faster and used less memory than the lisp programs that preceded them mdash  __label__memory
in c you would use malloc to get memory realloc to get more memory and free to release memory  __label__memory
if the dominant memory usage is program data structures then i wouldn t be at all surprised to find pypy using significantly less memory than cpython whether or not the jit was enabled  __label__memory
memset behaves like strcpy but the difference is that memcpy copied the data as it is byte but strcpy copies the formatted string as well so takes more time than memcpy to execute  __label__performance
first of all i recommend you to use ogg instead of mp3 has better performance  __label__performance
strncpy is more recommended that strcpy because protect your code against buffer overflow  __label__performance
at very high speeds amazon s3 does have some recommended request rate and performance considerations but this is only when making more than 300 put list delete requests per second or more than 800 get requests per second for a particular bucket  __label__performance
if you implement it yourself you should look into the metaphone or double metaphone algorithms i d recommend them over soundex which is not nearly as good at this type of task to store phoenetic representations of all your words  __label__performance
i would recommend swt over swing any day as it is very easy for an average programmer to create a responsive and native-feeling swt app while it takes a swing expert to create a decent swing app  __label__performance
this means with mef you have modularity from top to bottom wheras with prism modules are more granular units  __label__performance
perforce offers more advanced branching and merging capabilities than svn c  __label__performance
freemarker provides much better native whitespace handling recent velocity releases provide more interesting content controls  __label__performance
webrequest just offers you more functonality than webclient  __label__performance
in production it is much better to use a more sophisticated server like phusion passenger or unicorn since they have better performance than thin mongrel or webrick  __label__performance
keep in mind that i am using lodash by john-david dalton instead of underscore.js because lodash provides better performance and a custom build process  __label__performance
settimeout is better than setinterval here because setinterval will start at every 5 secs but settimeout will start once each time your job is done and wait for 5 seconds which will make your script adaptive to server response timings  __label__performance
tinyint or int for that purpose is indexed faster and gives better performance in sort or selects than varchar or chars  __label__performance
although this thread is more than a year old it still merits from the fact that no one mentioned about the not so recent innovations of nginx lighty and other web servers which scale much better than apache at higher concurrency and consume lesser resources  __label__performance
png is a newer format and often better than either jpeg of gif - especially for screenshots  __label__performance
the more hash-collision you have the worse the performance of hash maps because much of the hash maps good performance relies on as few as possible key in the same hash buckets  __label__performance
performance measurements of jython ironpython and cpython show that both jython and ironpython outperform cpython for some cases with large datasets  __label__performance
all in all jackson is considered to be faster but i ve also read that gson gives better performance when working with large objects  __label__performance
i m working with both ubuntu mac but i like staying with the linux system feels faster and more stable for me  __label__performance
is there a better way than show hide that would be easier on the memory performance  __label__performance
in this case keyboard input is essential and more important than mouse interaction  __label__performance
i personally would use aes for my encryption as it is lighter and more secure than tripledes in fact i think it is the de facto algorithm at the moment  __label__secure
i noticed calayer had worse performance than uiview  __label__performance
sometimes your mxml does not get you the itch of what you are looking and actionscript gives you more power  __label__performance
and if you have to convert to the same case to make comparisons toupper is better than tolower  __label__performance
use firefox network in development tools and check your requests sometimes it just sends options request in cross origin i insist on firefox because it s network tool is much more detailed than google-chrome and safari  __label__performance
we have previously used trac but have found redmine to be much more intuitive flexible and user-friendly  __label__performance
with these options jruby on rails gives about the same or better performance than mri  __label__performance
also pygtk is lighter than wxpython but i ended up bitting the bullet and using wxpython for the same purpose recently it is heavy but it didn t have any affect on the script performance  __label__performance
it is worth learning both because emacs is better than vim at editing certain languages and doing certain tasks and vice versa  __label__performance
final result will be of type ienumerable and in terms of performance this would be better than iqueryable since here join is taking place between in memory collections  __label__performance
phpmyadmin also shows the larger number however i have switched to heidisql since i find it s gui is superior for my local development  __label__performance
if your report processes large volume of data with aggregation sorting grouping having more ram improves performance  __label__performance
common lisp is a weakly functional mixed-paradigm language and scheme is more strongly functional but still not pure  __label__performance
if you have a mac i would recommend aquamacs which is a beginner-friendly version of gnu-emacs and therefore has all the power of emacs while still offering standard copy-paste save and other features including normal file dialogs and windows  __label__performance
i prefer zsh over bash because of its support for very powerful file globbing variable expansion modifiers and faster tab completion  __label__performance
there is icefaces which provides more semantic support than richfaces .also you can try nitobi suite which also provides similar kinda solution.if you are not satisfied with any of these i suggest try to write your own part extending the sun faces  __label__performance
if you re worried about the performance of calloc malloc might be faster simply due to the fact that it does not initialize the allocated buffer as calloc do  __label__performance
puremvc is more invasive than cairngorm meaning that your code is heavily dependent on the framework you have to subclass implement the framework classes interfaces but that doesn t mean that cairngorm isn t  __label__performance
i think testng is more suited for system tests than junit  __label__performance
in my opinion this is a more elegant solution than jsf and i think tapestry s ioc container makes it more powerful than wicket  __label__performance
google-chrome is more permissive with delimiters when it comes to dates thus formatting the date with dashes works with google-chrome but not with firefox  __label__performance
performance difference memcpy is usually more efficient than strcpy which always scan the data it copies  __label__performance
this type of flexibility is what draws me to bazaar despite the fact that git is wildly more popular and faster  __label__performance
however svn protocol is much faster so i suggest using collabnet svn for performance reasons  __label__performance
irrlicht has a cleaner api lower system requirements and works better across platforms than ogre in my opinion  __label__performance
we recently have migrated redmine from a server which was running under centos 5.5 with the same ror environment the same load the performance was a way better than on debian 7  __label__performance
though i would recommend using settimeout recursively instead of setinterval for better performance and the intended effect i guess  __label__performance
it uses less overhead than smb cifs and therefore acchieves greater performance - also - there are many versions of smb in many versions of windows that might not be compatible with each other  __label__performance
short answer dijkstra s is your best bet if you want just a few shortest paths and the floyd-warshall algorithm is better if you want to find the shortest paths between every pair of nodes  __label__performance
a dawg has better memory performance if the strings have many common suffixes but they are more expensive and difficult to build and update so start with a trie  __label__performance
quicksort has better locality of reference than mergesort which means that the accesses performed in quicksort are usually faster than the corresponding accesses in mergesort  __label__performance
zsh is more extensible and has a much greater focus on searching and completion than bash  __label__performance
aside from obejctive-c convention and best practices nserror is much more robust and flexibly than nsexception and allows the caller to effectively ignore the problem if they want to  __label__performance
skip-lists isn t any more difficult to implement than a self-balancing binary tree and gives much better performance in some situations  __label__performance
apc have less feature than memcached and is easly to use and optimize but this depends on your needs  __label__performance
i found the production of wmv much better and easier than flv because all windows flv encoders i tried are not really good and stable whereas pretty much every tool can natively output wmv  __label__performance
i have a uiview class hierarchy that has self.layer.shouldrasterize turned on in order to improve scrolling performance all of them have static subviews that are larger than the screen of the device  __label__performance
colt does this already but i have found it is more complicated and more powerful than jama which may explain why simple functions are slower with colt  __label__performance
glassfish however performs better than jboss and has a very slick gui-based admin console whereas jboss can only be administrated with a command line  __label__performance
i d recommend datamapper for orm not only it s way faster than activerecord but it s also very modularly built and plugins are actual gems that you can easily install  __label__performance
it seems activemq is better than rabbitmq in the sense that it is easy to set up and maintenance for cluster  __label__performance
after searched in google found that jackson has better performance than gson i plan to replace gson with jackson in my project but i got a diffrent result when run test code  __label__performance
generally you can have as good performance for reading as in myisam in innodb tables - you just can use count without where clause and you always should have a suitable index for where clauses as in innodb table scan will be slower than in myisam  __label__performance
that being said it s not like i think event-based programming is all just a ruse seeing as how it seems to have been the primary driver allowing such http servers as lighttpd nginx whatever to overtake apache in highly concurrent performance  __label__performance
cakephp is newer more feature rich and heavier than codeigniter  codeigniter is designed to have a much smaller footprint so you will most likely find yourself creating functionality in codeigniter to match cake s  __label__performance
unfortunately g++ packed the structs significantly looser than gcc which caused significant problems sharing objects between c and c++ code  __label__performance
of course you just asked for advice about sorting on stack overflow so i feel compelled to ask you if you need an in-place sort what kind of big-o performance you re looking for and then ask you to choose between quicksort introsort heapsort mergesort and stoogesort for what will work best for you  __label__performance
the waf benchmark has less of a pronounced difference in performance and i d guess that the answer would be more complicated some factors pypy does better some factors cpython does better and overall cpython comes out slightly ahead  __label__performance
subjective phpunit provides much nicer code coverage reports than simpletest  __label__performance
matz himself prefers merb over ruby-on-rails 2 because ruby-on-rails create a dsl on top of ruby which is really against the ruby philosophy  __label__performance
postgresql supports some more security features than mysql for example integration with gssapi or kerberos for logins last i checked mysql didn t have these  __label__performance
as a side note many folks recommend lxml for parsing html xml over beautifulsoup now for performance and other reasons  __label__performance
personally i would recommend using aes as its very easy to implement and with it being sensitive personal data would provide enough encryption to keep people out unlike something like des  __label__performance
however a linkedhashmap is faster as seen here treemap has o log n performance for containskey get put and remove according to the javadocs while linkedhashmap is o 1 for each.  __label__performance
one of the largest benefits of ironpython is that it has effectively no gil - meaning that if you are both writing python code and it is multi-threaded - you can often get performance that is better than cpython without having to spawn multiple process and pickle objects across the boundaries  __label__performance
ironpython has had more time to focus on performance improvements but ironruby has made significant performance improvements as of late  __label__performance
jboss is a big and quite complex application and glassfish is smaller and i find it easier to understand  __label__performance
get has the ability to outperform post requests  __label__performance
sorteddictionary offers same advantages than sortedlist but performs better if values to insert are not already sorted  __label__performance
i know that declarative way is cleaner but sometimes imperative programming makes your business safer  __label__performance
disable antialiasing and the performance of direct2d will be on par or faster than gdi  __label__performance
wxpython has a very good demo and it can do pretty much anything which pyqt can do i would anyday prefer pyqt but it may bot be free for commercial purpose but wxpython is free and is decent cross platform library  __label__performance
generally the performance of hard filesystems like ntfs is better than that of traditional unix filesystems  __label__performance
when one of the strings is a prefix of another the performance of compareto is worse as it still needs to determine the lexicographical ordering while equals won t worry any more and return false immediately  __label__performance
i suggest postgresql it s more capable has more features and better support for complex queries and datatypes than mysql and has a lot of tuning options  __label__performance
i d also recommend postgresql over mysql if you are going to have nested comments as postgresql does hierarchical querying better than mysql  __label__performance
actually genson is faster and has more features than gson and has performances close to jackson but its a lot more lightweight see  __label__performance
the floyd-warshall algorithm has a worst case performance of o |v|3 where as dijkstra s has a worse case performance of o |e| + |v|log |v|  __label__performance
usually multiplication has a higher precedence than addition but the grammar you have posted has the reverse that might be part of your problem  __label__performance
i prefer keyboard shortcuts rather than the mouse so these 3 shortcuts helps me a lot  __label__performance
since mantis is a bit more complete than bugzilla when it comes to features you could define separate issues with custom field for your tasks  __label__performance
further uppercase comparison is more optimized than tolower if that tiny degree of performance matters  __label__performance
reason i once heard that protected is better for hibernate performance but all i can find on the web is hibernate can access public private and protected accessor methods as well as public private and protected fields directly  __label__performance
typically you would not allow a http client to determine the uri of a new resource so a post to blog would be safer than a put to blog article-uri although http does cater for appropriate responses should the server be unable to honour the intended uri  __label__secure
you should use a strong cryptographic hash function and a salt to make it more secure  __label__secure
get method is not safer than post data never trust datas coming from the client side  __label__secure
using a encypted method with a salt would be even safer but this would be a good next step past just using a md5 hash  __label__secure
in effect post is no more secure than get  __label__secure
finally sha1 hash are safer than md5 i tell you that because you used the md5 tag in your post  __label__secure
tortoise now has an option push new branch that may be safer than force pull or push  __label__secure
des is the least secure 3des is better but i d go for the aes  __label__secure
ps again i am aware that relying on client-side script is way less secure compared with handling all execution from within the server-side  __label__secure
as for reliability i think that postgresql is more reliable especially when compared to mysql using myisam - innodb is a lot better here  __label__secure
use daemons mode and then simply touching the wsgi script file when an atomic set of changes have been completed isn t that hard and certainly safer than a systemd which restarts arbitrarily when it detects any single change  __label__secure
swift in that case would not be safer but less safe than objective-c  __label__secure
the very latest versions of google-chrome and firefox can still be installed on windows xp and anybody who doesn t believe new versions of google-chrome or firefox are vastly more secure than ancient bug-riddled ie6 is fooling themselves  __label__secure
myisam is often faster than innodb but isn t safe to use in a production environment for critical data  __label__secure
i find the best way is to create a cache session folder in your systems directory is more safer i put important things like logs and cache in system rather than application folder  __label__secure
it was therefore deemed safer for the beginners to default to myisam and expect those that now what they are doing to amend the config or specifically select innodb in phpmyadmin when they know that is the table type they want to use  __label__secure
in addition to what s already been said about threadsafeness non-atomic properties are faster than atomic accessor  __label__secure
with a salt md5 is much more secure than without but you re better off using one of the sha hash such as sha256managed  __label__secure
yes that may since your allocating with new but deallocating with delelte yes malloc free is safer here but in c++ you should not use them since they won t handle de constructors  __label__secure
using sha256 with a salt will be much more secure than md5  __label__secure
also instead of using atoi use the safer counterpart strtol  __label__secure
innodb is relatively newer than myisam and is transaction safe  __label__secure
this method also allows you to put the url within the action parameter of the form and uses post which is more secured for transferring password information  __label__secure
it is also non-standard unsafe and non-portable basically worse than using malloc and free in c++  __label__secure
with a salt md5 is much more secure than without but you re better off using one of the sha hash such as sha256managed  __label__secure
while 256-bit aes might sound less secure than 4096-bit rsa they might actually be quite similar from the offered protection  __label__secure
with correct locking for safety reasons and heavy concurrent use postgresql performed better than mysql  __label__secure
alternatively can i use something far way better and way more secure by using ucma or ucwa or any other api.  __label__secure
one more thing some guys would misunderstand that post is safer than get as user can not see the sent data  __label__secure
sodium_crypto_generichash which is blake2b a hash function more secure than md5 but faster than sha256  __label__secure
tuning innodb which is the better engine requires adjusting different values than myisam which is often the fast-but-unsafe default  __label__secure
in short as an authentication protocol kerberos is far more secure out of the box is de-centralized and will put less load on your directory authentication servers than ldap will  __label__secure
tcp is much better than udp in terms of reliability  __label__secure
firefox is clearly less secured it deliberately allows something that google-chrome locks down  __label__secure
now personally i generally use a salt sha-256 hash on my passwords because i thought that md4 and md5 were no longer secure and that hashing a password multiple times would just put too much strain on a server for no practical benefit  __label__secure
but even in that approach i always prefer to use the safer strncmp than strcmp  __label__secure
the wrapper uses these in such a way that even the md5 implementation is significantly more secure than a simple hash  __label__secure
asymmetric encryption ex rsa is no more secure than symmetric encryption ex aes  __label__secure
post is a little safer than get because the parameters are not stored in browser history or in web server logs. also data is not displayed in the url  __label__secure
edit again one completely different approach would be to use pypy s sandboxing mechanism which should be much more secure than cpython plus a sandboxing module  __label__secure
it seems to me that using an unsigned integer type is safer as the constructor can then never be called with an invalid parameter value  __label__secure
using a encypted method with a salt would be even safer but this would be a good next step past just using a md5 hash  __label__secure
http put isn t inherently any more secure than http post if you re allowing the uploaded files to be exceuted on your server  __label__secure
i need a sip server hopefully simpler more efficient and more secure than asterisk or other full-featured pbx to just terminate sip calls and play audio based on the incoming number  __label__secure
if your shell is bash or ksh or zsh it s much safer and easier to build up a command with an array rather than a string  __label__secure
udp might be faster than tcp but it doesn t have the error detection and correction you are going to need in order to have a safe transfer of data  __label__secure
post data isn t inherently more secure than get data  __label__secure
if you want to do this - and are in-fact okay with having more larger hash data to store compare - you would be much better advise to simply run a different hash function other than md5 that is either more secure and or uses a larger number of bits  __label__secure
on the other hand the secure tunnel created in a vpn is far more secure than remote desktop  __label__secure
note also the functions strncmp and memcmp which are similar to strcmp but are safer  __label__secure
in this situation storing password hash and the salt is more secure than storing the credentials encrypted or not because an attacker would have no way of getting the password back even if he manages to get his hands on both the hash and the salt  __label__secure
post is more secure than get this is just a quick example  __label__secure
strncmp is a little bit safer than strcmp because you specify how many comparisons will be made at most  __label__secure
the framework has also improved majorly not to mention it supports pdo mysqli more secure than mysql and postgresql  __label__secure
you may also try to signal the same page about a valid log-in by sending some information to the same page using the post or get methods post is more secure but i don t recommend it for this purpose at all  __label__secure
that code appears to be less secure than the bsd solaris versions since it doesn t take into account the saved setid bits  __label__secure
words like arbitrary processing and neither not safe make post sounds less secure than put when there is a choice  __label__secure
this one s an overflow but i think it illustrates the unreliability of isnumeric in general especially for int - for double it s much more reliable  __label__secure
we plan to use gson extensively in the application as it seems safer and better than jackson  __label__secure
double md5 hashing is actually less secure than a single hash with some attack vectors  __label__secure
hash password by using security salt is more secure than plain text password  __label__secure
note this example also demonstrates that it is not safe to use select max id +1 or select min id -1 as the next available unique value if we do it under concurrency  __label__secure
the engine is myisam i ve heard people recommend switching to innodb but many others said myisam is faster with large amounts of data in terms of counting and innodb better for safe transactions  __label__secure
for instance if the high word is less than the modulo then it is safe to perform the division like this  __label__secure
while i think the move to swift is prudent but i think it overstates the case to argue that swift is significantly more secure that objective-c  __label__secure
if you want to be more secure you can send the sms s more often however there is a way to understand sim-card change this is for t-mobile and europe use i guess from within the app so that the user cant fool you by enetering sms for a different msisdn and then change to his her real msisdn sim card  __label__secure
use a secure hashing algorithm like pbkdf2 a good one out of others and compare hash later on  __label__secure
also your comparison would be safer as a for-loop that ensures value is less than 100 rather than a while loops  __label__secure
here s the question it seems that only one cfwritestreamwrite call is safe free of blocking per each kcfstreameventcanacceptbytes notification because from the second call we can t guarantee that the socket is ready to accept more data  __label__secure
one of the reasons we want to move is because swift is more secure than objective-c  __label__secure
if you want the entire communication to be secure not only sending username password you can use a symmetric cipher algorithm aes because asymmetric cipher algorithms rsa are much slower and consume more resources  __label__secure
it is supposed i think that the algorithm cost and salt is used to make the life harder to hackers and if i use that my hash will be safer  __label__secure
but as i understand it ntlm disallows the more secure kerberos domain credentials if they re available  __label__secure
sockets can work as could udp multicast careful there though no way to know if a message was missed which is why tcp sockets are safer  __label__secure
block crypto algorithms like aes do suffer from this problem too but without a pki aes is no less safe than rsa  __label__secure
well unless you re targeting older than google-chrome 1.0 firefox 8.0 ie 4.0 opera 7.0 or safari 4.0 it s safe to use insertadjacenthtml  __label__secure
for example if the data needs reliability it will create a socket with sock_stream so it will select tcp otherwise if it doesn t need any reliability i will use sock_dgram for udp  __label__secure
locking unlocking in the getter setter is much safer you cannot forget to do it and more convenient the lock does not have to be directly accessable everywhere you use the property than an external lock on every property access  __label__secure
alternatively scrypt bcrypt or pbkdf2 provide more secure algorithms  __label__secure
client-side validations can be overriden hacked thus server-side are more secure  __label__secure
if that s true then you might not need all the transactional safety provided by the innodb storage engine and you might be able to get away with switching to myisam which is considerably more efficient on aggregate queries  __label__secure
a subform of assigned children would be safer or an assign form listing only unassigned children that includes a combobox based on the child table parent id foreign key to select a parent  __label__secure
using a solution such as a prepare statement where it is not possible for a user to directly influence the actual sql query being execute is a safer alternative  __label__secure
one thing to note is that std istream getline is more secure than std getline so should be preferred in some situations  __label__secure
characters post is more robust and secure than get  __label__secure
using a non-reversible hash such as md5 is much more secure and you can store the hash value as clear text  __label__secure
i know that declarative way is cleaner but sometimes imperative programming makes your business safer  __label__secure
actually you can insert the passwords as a simple md5 hash it will still work for letting the user login though it is recommended to then change the password through the front end system as the salt passwords are more secure  __label__secure
int needs more memory than what chars occupies and the conversion cannot be done in a safe manner  __label__secure
the hash idea should work minor note that sha-256 wouldn t present collisions md5 is no longer secure but it depends on the trade-off if the service involves something really really critical a client-side ssl certificate would be the best way to proceed  __label__secure
server-side validation is more secure than the client-side as the user cannot see the code even he does a view-source  __label__secure
udp is also more work than tcp if you need reliability which is built in to tcp  __label__secure
as a side note from what i ve read key derivation functions pbkdf2 scrypt bcrypt are considered better more secure #1 #2 than plain salt sha-1 sha-2 hash by crypto people  __label__secure
udp will almost always provide better performance than tcp at the cost of reliability  __label__secure
in my experiance with the two postgresql has shown to be faster on most write operations while mysql is slightly faster on the reads  __label__speed
typically mergesort is slower than heapsort and quicksort but that s usually under the assumption that comparisons are fast  __label__speed
often using int math is faster than doubleint multiplications however are only 1.5 times faster than double multiplications  __label__speed
use socket for tcp and datagram for udp its a lot faster than tcp but less connection oriented  __label__speed
as a rule of thumb floating-point is about 2x slower than integer on  __label__speed
typically operations like addition and subtraction are much faster in integer -- multiplication and division less so  __label__speed
if everything works use apc or memcached instead of files files usually work great but apc memc are faster  __label__speed
you may want to use the rabin hash which is faster and more collision resilient than cryptographic hash such as md5 sha1 et al  __label__speed
note that just as you wrote this version is significantly slower than the inline one under cpython which of course does no jit inlining  __label__speed
it s 4 times faster than using malloc free and copying your data when scaling up  __label__speed
note that using the linq min and max functions are faster than sorting the input for larger datasets o n vs  __label__speed
also note that they are much slower than proper getter and setter  __label__speed
in my understanding repeater is most suitable since it faster than gridview  __label__speed
lastly you might consider using float or double you might think int would be faster however that is not always the case as floating point operations can be more heavily optimised both in hardware and the compiler  __label__speed
i was expecting that udp would be faster but tcp is on average two times faster than udp  __label__speed
using firefox even it s slower than google-chrome it s still more respectful of privacy  __label__speed
setter and getter are somewhat slower than accessing fields directly so if you are doing heavy maths and read write these fields a lot in your subclasses you should go for accessing the fields directly  __label__speed
while not really a console skulpt.org runs python code client-side with no plugins or anything which makes it a lot faster than a server-side prompt  __label__speed
in general the dbx prior versioning code we upgrade from was faster at executing queries than firedac  __label__speed
this type of flexibility is what draws me to bazaar despite the fact that git is wildly more popular and faster  __label__speed
as you have already seen when you eliminate memset datasrc 0 n the first memcpy is even slower because the pages for the source must be allocated as well  __label__speed
we have a few clients who have very high traffic sites running apache slower than nginx with varnish in front of it and they get way more traffic than you are saying with little to no performance problems  __label__speed
i have written a memory allocator that is supposedly faster than using malloc free  __label__speed
in practice i know that using getter setter are slower than using function calls and that function calls are slower than directly accessing public variables  __label__speed
note how browsers that use v8 google-chrome opera 20 are slower with the delete than without it  __label__speed
mostly interpreted-language are a bit slower compared with compiled-language but i guess the difference is almost negligible in coffeescript javascript because of node.js  __label__speed
so for instance heapsort is faster than quicksort in the worst case but slower in the average case  __label__speed
while ruby and rails don t change as often as they did a few years ago the dev ecosystem still evolves faster than linux distributions like ubuntu can keep up with  __label__speed
when i try the demo in google-chrome or safari it is indeed much faster but when i ve tested it in firefox it s consistently slower  __label__speed
in case of unsigned integer division this problem does not arise which is why generally integer division works much faster for unsigned types than for signed types  __label__speed
the keyboard is almost always faster than the mouse  __label__speed
you re unlikely to find anything faster than the min and max functions  __label__speed
at the very least i would have expected that before memset b 0 len that memcpy would be slower because the of lazy allocation first touch on the first of the 100 iterations  __label__speed
the atom feed option seems to load faster than the rss one fwiw  __label__speed
directx is in general much faster than gdi due to the fact that it has full acceleration on most video cards  __label__speed
however some of them like md5 have less possible hash and execute faster  __label__speed
sodium_crypto_generichash which is blake2b a hash function more secure than md5 but faster than sha256  __label__speed
des is usually substantially slower than aes on modern hardware and has keys that are far too short for modern use  __label__speed
since these are typically orders of magnitude slower than the processors from the cpu s perspective this takes forever  __label__speed
non-crypto hash are often faster than crc-32 and produce more random output similar to slow cryptographic hash md5 sha  __label__speed
as you run queries it has to fetch data from disk which is much slower than ram  __label__speed
and that is for performance reasons assuming that a gethashcode implementation should always be much faster than an equals implementation  __label__speed
i tried replacing the gridview with a listview and the scrolling of the listview is much faster  __label__speed
in a native application i would use udp for the most data player position ... because it s way faster than tcp and it s uncritical when it is lost  __label__speed
only one disk read - since the disk is much slower then ram -  __label__speed
maybe division between double and int is faster than it between double  __label__speed
i was wondering if someone could explain to me why field access seems to be slower than getter setter method access and also why the last 8 iterations execute incredibly fast  __label__speed
int multiplications however are only 1.5 times faster than double multiplications  __label__speed
re-order your script so the subtraction test is timed first then the addition and suddenly addition becomes the faster operation again  __label__speed
furthermore 3des is much slower than aes  __label__speed
additionally with the base being a power of 2 the modulo and division operations are much faster than with your base-10 approach  __label__speed
it is slower than os-x and safari but tolerable and you may have some issues when google-chrome s developer tools don t quite match safari but it s much better than nothing  __label__speed
int are slightly faster but you d have to be microbenchmarking to notice. there s a small percentage difference between int and long and float and double but basically if you can afford one you can probably afford the other  __label__speed
you are right that the kinect is rarely used where a keyboard mouse would be faster and more accurate but note that it is potentially relevant for accessibility  __label__speed
in that case some hash functions are somewhat faster than other md5 being one of the fast functions but md4 is faster and it is simple enough that its code can be included in any application without much hassle  __label__speed
it s just a little slower than using apache bench directly against nginx  __label__speed
i m working with both ubuntu mac but i like staying with the linux system feels faster and more stable for me  __label__speed
if you just want the fun of linux command line programs without access to all of ubuntu cygwin is smaller and might be faster  __label__speed
because of how google-chrome s plugin system works development mode in google-chrome is much slower than in firefox or safari see here for more details  __label__speed
mysql i am told can be optimized to do faster reads than postgresql but both are pretty ridiculously fast in terms of # transactions sec they support and it doesn t sound like that s your problem  __label__speed
a realloc can occur significantly faster than a malloc memcpy and free  __label__speed
the problem is that memcpy is only slighly slower than memset when i expect it to be about two times slower since it operations on twice the memory  __label__speed
listview gridview is more work but is faster  __label__speed
fast clicking on ie has slower response than firefox google-chrome and safari  __label__speed
in my opinion calling getter and setter is slower than direct access to a field  __label__speed
they are slower less efficient than addition subtraction but they are much faster than looping and doing repeated additions  __label__speed
i thought iis should be faster than or at least as fast as cassini  __label__speed
i m testing some simple benchmarking calculations on win7 and linux ubuntu 16 to compare the timings and being wonder win appears to be much faster than linux  __label__speed
udp should be much faster than tcp because there are no acknowledge and congestion detection  __label__speed
python is an interpreted-language so by definition is slower than other compiled-language but the drawback in the execution speed is not even noticeable in most of applications  __label__speed
get is simpler and faster than post and can be used in most cases  __label__speed
but sometimes postgresql is faster than mysql or mariadb  __label__speed
as you suspect a normal free and malloc would be faster but that s because they do less  __label__speed
for a counterexample i think scheme programs ran faster and used less memory than the lisp programs that preceded them mdash  __label__speed
even though gethashcode itself should be fast it s not mostly faster than equivalent equals  __label__speed
reading and writing raw arrays of int and double will be faster than converting to and from text but then you need to worry about byte ordering differences in sizes for different platforms compilers structure padding etc  __label__speed
there exist battery-backed packages of ram modules which can act as an ultra-fast hdd substitute but if they attach via sata scsi or other typical disk interface the still are slower than system ram  __label__speed
it can be quite much faster than md5 sha functions and it produces good hash considering it output but it produces a smaller range of hash 64-bit output and as such is more likely to cause more conflicts  __label__speed
md5 hash would be faster than comparison but slower than a normal crc-check  __label__speed
the repeater is still faster than the gridview but the difference shouldn t be big if you code it right  __label__speed
as you see md2 is also much much shower than the other hash the same outcome as with the php code but md5 is much faster than sha-1 and overall it took less time in delphi to do the same on the same machine as php  __label__speed
an interpreted-language will typically run one to two orders of magnitude slower than a compiled-language  __label__speed
if the multiplication is truly faster than the addition then i expect somebody well-versed in byte code could explain why the load_fast for num is faster than the five operations for line 12  __label__speed
so gethashcode should be much faster than actually running equals  __label__speed
swt became slower than swing because it uses proxy to os widgets  __label__speed
incidentally the scrolling on the windows version of safari is fine albeit a little slower than ie opera and firefox  __label__speed
the justification of realloc is that it s faster than 2nd malloc manual copy free  __label__speed
accessor properties with getter and setter are much slower than real get set methods  __label__speed
on modern hardware floating point multiplications may run way faster than int ones so you might want to change the entire algorithm and start using double instead of int  __label__speed
i would choose option 1 for better performances apc or memcached are faster storage than filesystem and for having more control on what s happening in your project  __label__speed
disk even ssd are orders of magnitude slower than ram  __label__speed
normally quicksort is faster than mergesort which is faster than heapsort  __label__speed
even though vmware has been faster for me i still use virtualbox because it s good enough and is free and im cheap  __label__speed
ssd disk are good but they are still much slower than ram  __label__speed
purpose of having individual svg for each bullet chart is to make their management show hide remove easier  __label__useeasier
in vb.net the default behaviour is the same as vb6 to make it easier to upgrade legacy code  __label__useeasier
use thin instead of webrick - thin seems easier to configure for ssl  __label__useeasier
yes but if joomla is any example of how hard it is to implement a complex custom website with oop then wordpress is far easier and quicker and time is money  __label__useeasier
this feature allows the processor to execute several arithmetic operations simultaneously often four 32-bit integer operations or four 32-bit floating-point operations sometimes more operations with narrower integers sometimes fewer operations with 64-bit floating-point  __label__useeasier
avoiding them by modifying vb6 is lot easier than fixing the issues in vb.net  __label__useeasier
i ve used bugzilla and mantis but i prefer mantis simplicity  __label__useeasier
delphi users might want to look at free pascal s paralel implementation of libchm since a pascal solution makes it easier embeddable  __label__useeasier
this is sometimes easier than yacc bison and usually more intuitive  __label__useeasier
because you can created very targeted css show hide could be easier round corners and adding text for accessibility will be easier etc  __label__useeasier
declarative code is easier to make bug-free than imperative code  __label__useeasier
since the hash is generated using the original long salt using a trimmed salt later would just yield an invalid hash when specifying the original password - it doesn t make it any easier to find a hash collision  __label__useeasier
i actually found the setup of nginx much easier than lighttpd not to mention that you can install a macport of nginx port install nginx +ssl that does not contain the ssl-breaking bug that lighttpd suffers from here  __label__useeasier
i found simpletest was even easier than phpunit to set up  __label__useeasier
so using filewriter wrapped in a bufferedwriter to make it easier to write a new line  __label__useeasier
fwiw i find sproutcore to be easier to work with than cappuccino if you re interested in heavier non-progressive enhancement frameworks  __label__useeasier
if you have not programmed assembly before i suggest you choose mips since it is easier than x86 and then b looking at how to transfer data with the serial port to begin with since this illustrates memory-mapped i o that is used  __label__useeasier
it may not be the most elegant method but when you just need to convert something ad-hoc thinking of it as comparison and subtraction may be easier than division  __label__useeasier
here for what it s worth is a pipes-csv variant which just compresses each parsed row into an unboxed vector of int s by hand this easier than finding double which is what this csv is really storing using readint from the bytestring package.  __label__useeasier
using just the keyfn return a comparable value that matches your requirements is much easier than implementing comparator  __label__useeasier
localization it s easier to translation text than images  __label__useeasier
it seems like you only need one column of commandeditors so jlist would ve been easier to use had it support cell editor like jtable does  __label__useeasier
on linux it would be easier for you to link to shared library and use symlinks to correct version - imo it s much easier than using dlopen + dlsym  __label__useeasier
note extends mouseadapter is easier since you only need to implements the methods you want to handle  __label__useeasier
for a simple image toggle you might have an easier time with a hide show style instead  __label__useeasier
i think beautifulsoup or even bare lxml would be easier  __label__useeasier
entity-relationship diagram may be easier for you to learn  __label__useeasier
i also find sorting and filtering is also easier on windows forms  __label__useeasier
enabling the comparison value to contain spaces making it easier to parse the delimiter from the value  __label__useeasier
the comaddin base class makes it a bit easier to create an office add-in and reduce infrastructure code to be more familar with vsto - thats the whole idea  __label__useeasier
that way they are in a separate file that can be parsed a bit easier than a maven pom.xml  __label__useeasier
i find that the swing library is easier to use than awt although you do still have to use awt for listeners  __label__useeasier
because sml is eagerly evaluated the execution model is far easier to comprehend and debugging via printf works a lot better than in haskell  __label__useeasier
i would prefer show hide instead of delete and re-new as this is surely easier to implement more efficient and less error-prone  __label__useeasier
readability is a big reason for functions using recursion rather than loops makes them easier to follow and for using the iteration methods where possible map to transform an arrays values-by-value rather than a for-loop  __label__useeasier
so if you are just starting out beautifulsoup may be easier to use instantly but in the end i believe lxml is more pleasant to work with  __label__useeasier
drupal makes it easier for the developer to accomplish much more complex tasks than joomla or wordpress  __label__useeasier
if the salt is hard-coded into a popular product lookup tables and rainbow tables can be built for that salt to make it easier to crack hash generated by the product  __label__useeasier
my vehicle objects are in an arraylist which is iterated through with a for-loop i know a foreach loops would be easier but this is part of the assignment  __label__useeasier
wxpython is probably easier than pyqt or tkinter i don t want to start a framework war  __label__useeasier
it sounds from this that it would be much easier to use declarative styles all the time but there s usually a steep learning curve for declarative languages and most people prefer imperative  __label__useeasier
tcl might be easier to embed than perl but i do have to agree matthew scharley s reasoning  __label__useeasier
getting your project migrated to vb.net is certainly easier when you keep the old vb6 controls  __label__useeasier
between cruisecontrol and teamcity teamcity is faster and easier to set up but you may need to check on licensing for it  __label__useeasier
treating numerical data as numerical data and in a dataframe is far easier than maintaining spaces delimiter string conversions imo  __label__useeasier
if you re using googletest you may be able to use gmock to make this easier  __label__useeasier
this will make your work easier as searching sorting filtering than handling 3 parallel arrays  __label__useeasier
lxml enables you to search for elements using xpath which i think is easier than using beautifulsoup s api  __label__useeasier
while webclient may appear to be easier to use than httpwebrequest it is less flexible and will automatically perform it s callback on the ui thread and if you re downloading files in the background you almost certainly don t want this  __label__useeasier
there are lists available on the internet with millions of already hash values to make hash cracking easier those are known as rainbow tables and they can be easily countered with the use of salt  __label__useeasier
the conversion between binary and either octal or hex is even easier than decimal  __label__useeasier
you would be able to circumvent this by first running mvn clean install on magnicompcommon s pom.xml then on model pom.xml but this is much easier done by invoking maven directly on the root pom.xml  __label__useeasier
i am starting to understand that even though emacs is more powerful than vim vim is at least 10 times easier to use less keystrokes and requires way less modifications  __label__useeasier
also the show and hide functions are easier than animating the opacity  __label__useeasier
i have done some cross-platform development before on freebsd linux which was considerably easier - and i had people in the group with experience that i could talk to  __label__useeasier
i have heard that configobj is easier to use than configparser even though it is not a built-in library  __label__useeasier
the only problem is that we don t know what to use our very own engine with awt or if we could use swing to make it easier  __label__useeasier
implementing the equals and the compareto methods sounds easier than it sometimes really is  __label__useeasier
i ve used cxxtest and cppunit and found cxxtest to be easier to use it automates generating some of the skeleton code - on the downside it needs python installed and lightweight no libraries entirely header based  __label__useeasier
well sometimes performance and usability can be at odds but i ve found gson to be easier to use than alternatives like jackson org.json and others  __label__useeasier
xhtml has a stronger syntax than html and is easier to convert to apache-fop this way  __label__useeasier
sure there is a learning curve with maven but reading a pom.xml is far easier than reading a build.xml  __label__useeasier
i also checked prolog and it seems a pretty cool language easy to do relations between data and easier than lisp but i d like to hear what you think  __label__useeasier
or could you restructure into nested grouping to make it easier to filtering  __label__useeasier
there are libraries that build on the xml apis jdom dom4j or xom which are easier to use than the raw apis  __label__useeasier
you can use a while loops to achieve the desired results but a for-loop is much easier to implement in this situation  __label__useeasier
mouseover rather than on mousedown makes it easier to catch moving  __label__useeasier
with a little practice hex or octal are easier for a human than binary  __label__useeasier
if an ivar is going to be changed frequently declaring a properties and always using the accessor will make it easier to avoid memory management errors  __label__useeasier
if the only purpose is improved testability then exposing methods as protected or public is an easier option  __label__useeasier
struct foo is easier to parse then typedef d foo as the name-lookup is simpler  __label__useeasier
using prepare and execute should be faster safer easier and it won t make you feel like you re writing php in 1999  __label__useeasier
joomla and wordpress are easier to configure but not as customizable as drupal is  __label__useeasier
for a one man shop teamcity is far easier to setup and configure than cruisecontrol  __label__useeasier
a possible implementation for the sin and cos functions making it easier to define additional functions in the future could be having a something like  __label__useeasier
it s easy much easier than installing freebsd or god forbid opensolaris pretty straightforward and the perl and python will be 64 bits out of the box and part of default installation  __label__useeasier
a set or bag is easier to map in hibernate and requires fewer database columns  __label__useeasier
but its a good practice to always put the brackets to help making your code easier to read so you wouldn t get confused in more complex algorithms  __label__useeasier
usually you use strsplit to break a string in parts but with substr there s an easier solution for your problem  __label__useeasier
even though git-svn is easier to start with here are some further reasons why using the kde svn2git instead of git-svn is superior besides its flexibility  __label__useeasier
properties just made it easier to write accessor  __label__useeasier
folder objects undoubtedly give the fullest access to file information but the older dir function is easier to use and allows specification of a filename template so i have used that  __label__useeasier
it s probably easier to learn from scratch than cvs but i don t have experience that way. if someone needed a centralized source-control system i would recommend perforce as long as they had the resources to license it  __label__useeasier
for me they serve pretty same purpose to hide complexity except accordion is imho better for continuous-reading it s easier to quickly go to next section while tabs seems to be more random-access  __label__useeasier
cdi is so much more mature than seam 2 bijection jsf 2 is so much easier than jsf 1.2 that any kind of application development will simply be much more fun with seam 3  __label__useeasier
we found redmine to be a better than trac simply because it is easier to use  __label__useeasier
to achieve this you can consider instead of storing the state in an array to make use of .data to store the state show or hide is much easier to maintain and understand  __label__useeasier
ie provides mouseenter and mouseleave which are much easier to work with because they don t bubble but of course ie-specific  __label__useeasier
if the latter is what you want you could use rtf which is somewhat easier than the doc format  __label__useeasier
it seems that zsh is more configurable than bash but also more complicated  __label__useeasier
it is also possible to manipulate the inputs so that various parts of the calculation return 0 for addition or subtraction or 1 for multiplication or division to make testing easier but this only gets me so far  __label__useeasier
we chose to not do cascade since it is easy enough to traverse your own model and do deletes and when the other use case pops up where you just want to delete the parent entity but not children it is easier to code and not have to undo the cascade logic  __label__useeasier
i believe that ubuntu is better than centos when it comes to mono as it is much easier to setup and seems to be better supported  __label__useeasier
